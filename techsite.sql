/*
Navicat MySQL Data Transfer

Source Server         : jiawei
Source Server Version : 50717
Source Host           : localhost:3306
Source Database       : techsite

Target Server Type    : MYSQL
Target Server Version : 50717
File Encoding         : 65001

Date: 2018-05-11 16:33:02
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `tags` text NOT NULL,
  `time` text NOT NULL,
  `description` text,
  `codeText` longtext NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', '个人博客上线啦！！', '闲聊', '2018-04-02', '', '#t 个人博客上线啦！！\n\n当初刚开始接触前端时，我就希望自己有朝一日能够独立地开发一个网站，而今天就是这个希望变成现实的时候了，撒花。\n\n\n我的博客内容主要会有两个方面：web 技术学习总结和生活感悟。好像有点 kind of personal，不过也没关系，我估计也没别的人看，主要是给自己记录一下，日省吾身。');
INSERT INTO `article` VALUES ('2', '说说 java 里面的泛型', 'java,泛型', '2018-04-04', '## 前言\n\n公司 android 项目需要有人接手，任务落在了我这个既不懂 java 也不懂 android 的前端上，蛋疼的是我擅（zhi）长（hui）写的 javascript 还是弱类型语言啊！想不到博客一建好的第一篇文章居然不是老本行前端或 node 的，造化啊！后续会不定期更新与 android 相关的东西。\n\n## 概念\n\n上手一波查概念：\n\n> 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。\n\n**泛型，又称“类型参数化”，顾名思义，就是允许把一种对象类型当成参数传递处理**。这个就很灵性了，相比初始化固定一种类型，泛型应该是具有更广泛的类型处理能力。\n', '#t 说说 java 里面的泛型\n\n## 前言\n\n公司 android 项目需要有人接手，任务落在了我这个既不懂 java 也不懂 android 的前端上，蛋疼的是我擅（zhi）长（hui）写的 javascript 还是弱类型语言啊！想不到博客一建好的第一篇文章居然不是老本行前端或 node 的，造化啊！后续会不定期更新与 android 相关的东西。\n\n## 概念\n\n上手一波查概念：\n\n> 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。\n\n**泛型，又称“类型参数化”，顾名思义，就是允许把一种对象类型当成参数传递处理**。这个就很灵性了，相比初始化固定一种类型，泛型应该是具有更广泛的类型处理能力。\n<!-- more -->\n\n\n## 泛型的使用\n\n泛型有三种使用方式：泛型类、泛型接口、泛型方法。\n\n### 泛型类\n\n泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：`List`、`Set`、`Map`。这里举个栗子：\n\n```java\npublic class Student<T> {\n  private T word; // 要说的内容\n  \n  public Student(T word) {\n    this.word = word;\n  }\n\n  public T say() {\n    return word; // 说话动作\n  }\n}\n```\n\n例子中的`<T>`就是泛型的声明标志，而`T`则代表了某种数据类型。在类内部，还有一个类型为`T`的私有属性，一个接受`T`类型参数的构造器和一个将返回`T`类型的函数`say`。下面举个栗子，去具体化泛型的使用：\n```java\nStudent student_string = new Student<String>(\"Hello world!\");\nStudent student_integer = new Student<Integer>(123456);\n\nstudent_string.say(); // \"Hello world!\"\nstudent_integer.say(); // 123456\n```\n\n同一个类分别定义了一个具体为`String`类型和`Integer`类型的的实例。**定义的泛型类，就一定要传入泛型类型实参么？答案是否定的。** 在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。举个栗子：\n\n```java\nStudent student1 = new Student(\"string\");\nSrudent student2 = new Student(123);\n\nstudnet1.say(); // \"string\"\nstuendt2.say(); // 123\n```\n\n有点要注意的：**泛型的类型参数只能是类类型，不能是简单类型**。\n\n### 泛型接口\n\n泛型接口与泛型类的定义及使用基本相同。举个栗子：\n\n```java\n// 定义一个泛型接口\npublic interface StudentActivity<T> {\n  public T write();\n}\n\n// 定义一个继承接口的学生类\npublic class Student<T> implements StudentActivity<T> {\n  private T word;\n\n  public Student(T word) {\n    this.word = word;\n  }\n\n  @Override\n  public T write() {\n    return word;\n  }\n}\n\n// 使用\nStudent student = new Student<String>(\"Hello world!\");\nstudent.write(); // \"Hello world!\"\n```\n\n### 泛型方法\n\n**泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型**。\n\n泛型方法好像比较复杂，我其实没有太多时间、心思或兴趣在 java 上，所以就先记到这里了。如果后面有所涉及，再回来写吧。');
INSERT INTO `article` VALUES ('3', '分析 javascript 事件循环', 'javascript,事件循环', '2018-04-10', '## 问题\n\n咱先来看看下面这段代码：\n\n``` javascript\nconsole.log(\'start\');\nsetTimeout(() => console.log(\'setTimeout\'), 0);\nnew Promise(resolve => {\n  console.log(\'loop start\');\n  for (let i = 0; i < 10E4; i++) {\n    i === 10E4 - 1 && resolve();\n  }\n  console.log(\'loop end\');\n}).then(() => console.log(\'Promise\'));\n```\n\n正确答案是什么？（猜好了再点“阅读全文”）\n\n', '#t 分析 javascript 事件循环\n\n## 问题\n\n咱先来看看下面这段代码：\n\n``` javascript\nconsole.log(\'start\');\nsetTimeout(() => console.log(\'setTimeout\'), 0);\nnew Promise(resolve => {\n  console.log(\'loop start\');\n  for (let i = 0; i < 10E4; i++) {\n    i === 10E4 - 1 && resolve();\n  }\n  console.log(\'loop end\');\n}).then(() => console.log(\'Promise\'));\n```\n\n正确答案是什么？（猜好了再点“阅读全文”）\n\n<!-- more -->\n\n答案是：\n\n``` javascript\nstart\nloop start\nloop end\nPromise\nsetTimeout\n```\n\n如果你对答案有疑惑，或许是因为你对 javascript 的时间循环机制不熟悉，请抱着问题看下去。\n\n## 一些概念\n\n要把 javascript 的事件循环机制搞清楚，需要先了解一下下面几个概念。\n\n### javascript 与线程\n\njavascript 出生就是一门单线程的语言，经过23年的发展，虽然有 Nodejs 和 Worker 等的额外线程尝试，但目前的主要执行环境还是单线程，代码里是基本不会出现线程相关的知识。**但这就是否就意味着 javascript 与线程无关呢？**\n\n**是的，就是与线程无关。** 时刻记得，javascript 是单线程下执行的。\n\n### 执行栈 execution context stack\n\njavascript 线程有一个先进先出的堆栈，用于执行某些任务的代码。举个例子：\n\n``` javascript\nfoo();\n\nfunction foo () {\n  console.log(\'foo start\');\n  logInside();\n  console.log(\'foo end\');\n}\n\nfunction logInside () {\n  console.log(\'logInside\');\n}\n```\n\n假设我们现在有一个空的 execution context stack，上述代码的执行情况如下：\n\n* foo 被弹入栈底，foo 函数被执行；\n* 打印 \'foo start\'；\n* logInside 入栈，logInside 函数被执行；\n* 打印 \'logInside\'；\n* logInside 函数执行完毕，logInside 被弹出堆栈；\n* 继续执行后续代码，打印 \'foo end\'；\n* foo 函数执行完毕，foo 出栈；\n* 栈顶为 null，执行栈空闲；\n\n其实我对执行栈理解不深，也就充其量理解为一个存放执行同步代码的区域。\n\n### 事件循环 event loop\n\n基于 javascript 是单线程的，也就只有一个 execution context stack，那么 javascript 在某个时刻就只能执行一个任务，后面的任务只能排队，这个队列就称作**任务队列** 。实际上，由于网络请求或 IO 等耗时操作的存在，宿主（Node/Browser）也不可能傻乎乎地阻塞掉进程等待操作完成，所以实际上任务队列会存在多个的情况。当然，也有可能无任务的空队列。\n\n为了应付掉这些任务队列情况，宿主需要一种机制来处理，这个机制就是 event loop。event loop 会持续不间断地运行，以便于寻找适合的可执行任务，所以 event loop 会有一个循环周期（cycle），在这个周期内执行一些检查和任务的进出。\n\n在查阅资料时，看到一篇文章，看到有点有意思的东西，基本看不明白，但还是现在这 mark 一下。\n\n> Each \'thread\' gets its own event loop, so each web worker gets its own, so it can execute independently, whereas all windows on the same origin share an event loop as they can synchronously communicate. ———— [jakearchibald](http://https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ \"Tasks, microtasks, queues and schedules\")\n\n编写 chrome 浏览器的 Jake 大神说道：“每一个线程都有自己的 event loop，意味着每个 web worker 也是如此，因此每个线程内都有一个独立执行代码的区域，同时该区域也允许同源窗口可以进行同步通讯。”\n\n### macrotask\n\n上述的任务队列中，其实包括2种任务，分别是 macrotask 和 microtask。两者只差了一个字母，其实翻译过来的意思分别是\"宏任务\"/\"微任务\"，意义是刚好相反的。作为\"宏任务\"，macrotask 包括了下面几个方面的内容：\n\n* script；\n* setTimeout；\n* setInterval；\n* setImmediate；\n* IO；\n* UI rendering；\n* requestAnimationFrame 等；\n\n那对 macrotask 来说，它的队列是怎么形成的呢？对于 macrotask 的划分，其实会容易引起一点小误会，我自己对 macrotask 的划分总结了3个特点：**未被执行的**，**同一队列先后马上执行**、**可能会有多个队列**。由于这个是我自己总结的，可能会有点晦涩难懂，因此下面举个例子方便增加理解：\n\n``` javascript\n// 你应该知道函数声明的提升是在代码被执行前完成的，这意味着在 javascript 引擎里，代码的解析和执行属于不同的阶段。\n// “队列里的任务是还没有被执行的” 指的是这些代码还没有被执行，严格来说就是没有进入执行栈 execution context stack，\n// 但实际上，它们已经被初步解析，macrotask queue 形成。\n\nconsole.log(\'hello\');\nconst foo = () => console.log(\'foo\'); // 这些同步代码就是 script 类别。\n\nsetTimeout(foo);\n```\n\n可以直接肯定的是，`console.log(\'hello\')`和`const foo = () => console.log(\'foo\')`都是会被先后马上执行的，它们都处于 macrotask queue 中，姑且先把这个队列成为 A。但`setTimeout(foo)`呢？根据经验可知，`foo`函数一定是会被异步执行的，所以它不属于 A 队列，而属于另外一个队列 B。而`setTimeout`本身是被马上执行的，宿主会根据条件（定时器间隔，网络响应）创建另外的队列 B，所以`setTimeout`是属于队列 A 的。已异步为线，可以划分出2个 macrotask queue，但异步回调队列相互之间是怎样划分的，还有待研究（是否有研究意义？），如：\n``` javascript\nsetTimeout(() => console.log(1), 100);\nsetTimeout(() => console.log(2), 100); // 2个 log 是否属于一个 queue？更复杂的情况呢？\n```\n\n在这里，我们应该知道了 macrotask 是一系列类型代码的合集，它可能有一个或多个队列，以及如何划分队列。\n\n### microtask\n\nmicrotask 作为“微任务”，大体上和 macrotask 是相似的，它也是**未被执行的**，也是**同一队列先后马上执行**，也有一个 microtask queue，但也**最多只能有一个**。\n\nmicrotask 包含了以下这些类型的代码：\n\n* process.nextTick\n* Promises\n* Object.observe（[抛弃](http://https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/observe \"Object.observe 已被废弃\")）等；\n\n实际上，相较于`process.nextTick`，`Promises`，我认为用`process.nextTick callback`和`Promise.resolve(| reject)`来描述 microtask 更为合理。原因和在 macrotask 中描述的`setTimeout`一样，这些对象或方法包含了同步和异步，如果能分得更仔细一点，可能会让人更容易理解。让我们来看个例子：\n\n``` javascript\nnew Promise(resolve => {\n  console.log(\'Promise satrt\');\n  for (let i = 0; i < 10E4; i++) {\n    i === 10E4 - 1 && resolve();\n  }\n  console.log(\'Promise end\');\n}).then(() => {\n  console.log(\'resolve\');\n});\n\nconsole.log(\'hello\');\n```\n\n答案是：\'Promise satrt\'，\'Promise end\'，\'hello\'，\'resolve\'。嗯，没有什么新意。\n\n### macrotask 和 microtask 的执行\n\n前面我们学到了 javascript 只有一个线程，也只有一个 event loop 和 execution context stack，因此一个时刻只能执行一个任务。在面对多个 macrotask queue 和 microtask queue，以及各个 queue 的任务时，优先权重是怎样决定分配的呢？\n\n我总结了 event loop 的任务执行模型：\n\n* **检查是否有可执行的 macrotask queue，有则执行该 queue 的 macrotask，否则检查且执行 microtask queue 里的 microtask**；\n* **执行完一个 macrotask queue 后，立即检查且执行 microtask queue 里的 microtask**；\n* **执行完 microtask queue 后，算一个 event loop cycle，返回第一步进入下一个 cycle**；\n* **当前任务执行完毕后，会立即被移出栈**。\n\n这个模型的执行流程相对比较简单，只是为了方便我自己理解的。具体或更复杂的情况可能需要深入到宿主底层代码实现才可能得出结论。所以现在我们可以回头看看文章开始的题目了：\n\n``` javascript\nconsole.log(\'start\');\nsetTimeout(() => console.log(\'setTimeout\'), 0);\nnew Promise(resolve => {\n  console.log(\'loop start\');\n  for (let i = 0; i < 10E4; i++) {\n    i === 10E4 - 1 && resolve();\n  }\n  console.log(\'loop end\');\n}).then(() => console.log(\'Promise\'));\n```\n\n现在我们分析一下这段代码里的任务队列组成，按先后顺序。\n\n`console.log`，`setTimeout`，`Promise 同步部分`形成了第一个 macrotask queue；\n\n`setTimeout callback` 形成第二个 macrotask queue；\n\n`Promise.resolve`入栈 microtask queue；\n\n因此，按照模型，执行顺序应该是：macrotask queue 1 -> microtask queue -> macrotask queue 2，打印结果是：start -> loop start -> loop end -> Promise -> setTimeout。\n\n此外，由于 microtask 只有一条 queue，那**假如我在 microtask queue 被循环执行时再 push microtask 进去会怎样呢**？\n\n``` javascript\nconsole.log(\'start\');\nsetTimeout(() => console.log(\'setTimeout\'), 0);\nnew Promise(resolve => {\n  console.log(\'Promise 1\');\n  resolve();\n}).then(() => {\n  console.log(\'Promise 1 resolve\')\n  new Promise(resolve => {\n    console.log(\'Promise 2\');\n    resolve();\n  }).then(() => console.log(\'Promise 2 resolve\'));\n});\n```\n\n嗯，结论是：**只有 microtask queue 被清空时才会进入下一个 macrotask queue**。\n\n## 优先权重测试\n\n说出来你可能不信，同一个队列里的不同种类任务会存在优先权重差别。\n\n``` javascript\nsetInterval(() => console.log(\'setInterval\'));\nsetTimeout(() => console.log(\'setTimeout\'));\nrequestAnimationFrame(() => console.log(\'requestAnimationFrame\'));\nsetImmediate(() => console.log(\'setImmediate\'));\n```\n\n在 chrome 中的测试结果是：setImmediate, requestAnimationFrame, setInterval, setTimeout。\n\n别说在其他浏览器的情况，甚至在 Node 8.9.0 中，部分情况和 chrome 都不一样，所以实际上这种权重优先的情况具有很大的不确定性。鉴于实际对此方面的要求几乎为零，所以不作进一步研究。\n\n## 总结\n\njavascript Thread，execution context stack 懂个概念。\n\nevent loop 简单模型机制、macrotask 及 queues、microtask 及 queue 要懂。\n\n');
INSERT INTO `article` VALUES ('4', 'Android 异常未被捕捉的表现与处理', 'Android', '2018-04-16', '## 前言\n\nAndroid 程序对于代码错误的把控可以说是非常严格的，其错误可以分成“编译错误”和“运行错误”。编译错误问题不大，但**运行错误**通常发生在用户操作交互的过程中，一旦发生，App 或 Activity 的崩溃退出会对用户造成很糟糕的用户体验，降低用户对产品和公司的满意度，甚至会丢失用户。因此，尽量避免出现运行错误是一个 App 的基本底线，也是一个 Android 开发者的必备能力。\n', '#t Android 异常未被捕捉的表现与处理\n\n## 前言\n\nAndroid 程序对于代码错误的把控可以说是非常严格的，其错误可以分成“编译错误”和“运行错误”。编译错误问题不大，但**运行错误**通常发生在用户操作交互的过程中，一旦发生，App 或 Activity 的崩溃退出会对用户造成很糟糕的用户体验，降低用户对产品和公司的满意度，甚至会丢失用户。因此，尽量避免出现运行错误是一个 App 的基本底线，也是一个 Android 开发者的必备能力。\n<!-- more -->\n\n\n## App 运行错误表现\n\n下图是一个测试程序在 MIUI 下的报错信息：\n![alt](http://39.108.215.36/uploads/App报错（MIUI）_20180416112300.png \"title\")\n\n除了这个令人不怎么愉快的弹窗，在 MIUI 下，Activity 会被直接 destroy，然后回退到路由栈的上一个 Activity；如果异常 Activity 处于栈顶，则 App 直接退出。而这只是视觉上的效果，但实际上具体到 Activity 生命周期、路由栈状态和不同版本的 Android 的表现，仍然还是未知的，我也缺乏条件去研究，只能后面再回来更新了。\n\n## 捕捉处理\n\n对于我这种菜鸟 Android App 开发者来说，想要百分百概率地不出现运行错误是几乎不可能的。所以，当一个意外的异常错误出现时，开发者需要做什么工作来提升 App 和适当地挽回用户的情绪呢？我想到了以下几个点：\n\n* 错误信息 log 收集；\n* 重启 App；\n* 带歉意的提示语；\n\n那开发者如何才能知道运行错误发生了呢？答案是：应用主线程的 `UncaughtExceptionHandler`。`Thread.defaultUncaughtExceptionHandler`是用于处理程序中未被 `catch`的错误的方法，同时`Thread.setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)`也提供了让我们重写运行错误处理的方法。下面罗列一下具体步骤和做法：\n\n``` java\npublic class UncaughtHandler implements Thread.UncaughtExceptionHandler {\n  @Override\n  public void uncaughtException(Thread t, Throwable e) {\n    // handleException 方法做一些处理\n    if (handleException(e)) {\n      Process.killProcess(Process.myPid());\n      System.exit(1); // 0 表示正常退出，1 表示异常\n    } else {\n      defaultUncaughtHandler.uncaughtException(t, e);\n    }\n  }\n}\n```\n\n同时，我们需要写一个`Application`的子类，使用上`UncaughtHandler`：\n\n``` java\n// AndroidManifest.xml\n\n<application\n  ...\n  android:name=\".MyApplication\"\n```\n\n``` java\n// MyApplication.java\n\npublic class GoApplication extends Application {\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    // UncaughtHandler 应该使用单例模式，这里只是为了方便示例。\n    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());\n  }\n}\n```\n\n以上，就可以得到一个初步的自定义运行错误处理器，你可以把错误 log 信息上传至服务器，以方便进行后续的 fix 工作。\n\n## 运行错误后重启 App\n\n假如报错的 Activity 在处于栈顶，运行错误一下就难受了，App 直接退出，用户懵逼。尤其是我这种为工业设备开发 App 的人，有相当一部分的设备是无法触控的，App 开机启动后便自己不断跑着获取 JNI 信息。如果 App 意外崩溃，那用户就只能重启设备了。但注意！那可是工业设备，重启设备会承受更多风险，工业可靠性被降低，公司的名誉都会受到一定程度的损失。所以，我决定把它单独拿出来谈。\n\n事实上，要重启 App，在`Thread.defaultUncaughtExceptionHandler`中通过广播，服务或单纯的`Intent`都是做不到的，但`PendingIntent`可以做到。下面举个例子：\n\n``` java\nIntent intent = new Intent(mContext, mActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\nintent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);\nPendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\nAlarmManager alarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);\nalarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + delay, pendingIntent);\n```\n\n这样，我们就可以在 delay 毫秒后实现 App 重启，有兴趣的朋友可以试试。\n\n**注意**，使用此方法重新打开 App 的时候一定要做万全的错误`catch`，否则可能会出现死循环，你懂的。\n\n## 总结\n\n没啥好总结的，累人，只感觉Android 好难啊！~！超级多的类要记，真的是愁死人，还是我大前端好啊！我想，还是等我自己开发完一个 WebApp 框架后，我就再也不写其他 Android 代码了，只维护 WebApp 框架。\n');
INSERT INTO `article` VALUES ('5', 'HTTP 头部参值应为 ASCII 值', '短笔记,HTTP', '2018-04-26', '', '#t HTTP 头部参值应为 ASCII 值\n\n最近用 Koa2 返回 cookie 到客户端会出现选择性失败的情况，到源码查了下发现 Koa2 是对 cookie 值的编码作了校验，非得 ASCII 字符才能过。查了下文档，发现确实是这样，因此做个短笔记记录一下。\n[标准链接：cookie 值的编码校验](https://tools.ietf.org/html/rfc7230#section-3.2.4 \"cookie 值的编码校验\")');
INSERT INTO `article` VALUES ('7', '封装一个通用 Activity 类', 'java,Android', '2018-04-27', '## 问题\n\nAndroid 里写 Activity 的时候总是要写很多共同的东西，譬如：\n\n* 控件填充；\n* 异步网络请求+数据处理；\n* 通用方法：`Log`，`Toast` 等；\n\n这些东西往往具有共同性，所以我尝试把它们封装到一个基础的 Activity class 中去。\n\n', '#t 封装一个通用 Activity 类\n\n## 问题\n\nAndroid 里写 Activity 的时候总是要写很多共同的东西，譬如：\n\n* 控件填充；\n* 异步网络请求+数据处理；\n* 通用方法：`Log`，`Toast` 等；\n\n这些东西往往具有共同性，所以我尝试把它们封装到一个基础的 Activity class 中去。\n\n<!-- more -->\n\n## 实现\n\n### 修饰符 abstract\n\nJava 里面有一个修饰符 `abstract`，意思是“抽象”，它可以修饰类和方法，那它有什么用途呢？\n\n* 当 `abstract`修饰类的时候，这个类就会变成抽象类，这个类就不能生成对象实例，也就是说不能 `new`，但抽象类可以作为对象声明的类型。啥意思呢？就是说**抽象类可以当成父类来继承使用**，抽象类是一个**编译时类型**，只在编译时有效。抽象类是一个半成品，**一定要被子类继承并覆盖其中的抽象方法**。\n* 当`abstract`修饰方法的时候，方法就变成抽象方法，这个方法是没有定义实体内容的，需要子类去覆盖实现。\n\n### 实现例子\n\n举个例子：\n\n```java\n// 使用 abstract 修饰符定义了一个继承 Activity 的抽象类 BaseActicvity\npublic abstract BaseActicvity extends Activity {\n  protected abstract void initView (); // 抽象方法，无实现\n}\n```\n\n`BaseActicvity`是抽象类，是不能生成实例的。我尝试实现一下`BaseActicvity`的子类：\n\n```java\n// 使用 abstract 修饰符定义了一个继承 Activity 的抽象类 BaseActicvity\npublic IndexActivity extends BaseActicvity {\n\n  private LinearLayout demoListBox;\n\n  // 必须覆盖实现抽象类里的抽象方法\n  @Override\n  protected void initView() {\n    demoListBox = findViewById(R.id.index_demo_list);\n  }\n}\n```\n\n在上面的例子中，我把普通活动类里填充控件的代码都规范到抽象方法`initView`，然后在`onCreate`生命钩子里调用，这样就不会和其他用途的代码混合在同一个代码块中，保持了代码结构清晰，提升了维护性！\n\n## 总结\n\n没错就是这么短，我想实现或抽象其他共同的功能也就是举一反三触类旁通罢了。目前我还不熟 java 和 Android，你指望我自己折腾出更多的东西来，几乎是很难的，我现在基本就是自己想功能自己瞎摸索。后面学到啥新东西时，再回来更新吧！');
INSERT INTO `article` VALUES ('8', '从连等赋值看 AssignmentExpression', 'javascript', '2018-05-08', '## 闲言\n\n自从 Oracle 公司拥有 javascript 相关版权的行业文章出来后，我便开始有点担心我们要为所写的代码改名了。然而，我发现实际上根本没有任何浏览器厂商或其他 runtime 声明自己执行的脚本语言是 javascript，严谨的 Google 声明的是**ECMAScript**。OK，**ES**。\n\n## 问题\n\n我曾经看过，也写过**连等赋值**操作，形如：`let a = {b} = {b: 1}`。由于连等赋值出现频率低，带坑，我开始思考其存在的合理性，甚至怀疑**连等赋值**这玩意是不是开发者们利用赋值表达式返回值的特性而玩出来的一个小花样。对于赋值，简单情况下我们是习惯为单个变量单独声明初始化赋值或声明后二次赋值，语法形如：`declare name = value;`，复杂一点的有解构赋值：`declare {x, y}= {x: 1, y: 2};`，这两种赋值方式都是简单规范的，不会出任何问题。但连等赋值？呵呵。\n\n```javascript\nconst {x} = {y} = {x: 1, y: 2} // x = 1, y = 2\nx = 3 // 报错：Uncaught TypeError: Assignment to constant variable.\ny = 3 // ok\n```\n\n可以看到，`y`是对`declareType`是不感冒的。而且这种赋值方式下的新变量可能会有污染的危险：\n\n```javascript\n(() => {\n  let a = b = \'hello\' // a = \'hello\'，b = \'hello\'\n})()\nb // \'hello\'\na // 报错：Uncaught ReferenceError: a is not defined\n```\n\n写到这时，你应该能确定所谓连等赋值只是一个小手段罢了。但我们是否应该不要过于关注，只要以规范的方式写代码就行了？也许吧，我们应该先看看下面的这行代码：\n\n```javascript\nconst b = a.c = (() => a = {b: 1, c: 3})().b = 4\n```\n\n该代码能否运行？下面这个呢？\n\n```javascript\nconst b = (() => a = {b: 1, c: 3})().b = a.c = 4\n```\n\n事实上，赋值表达式 AssignmentExpression 有大量的知识点是在日常的代码工作中无法被触碰的，或是可避免的，但它们却默默地发挥了作用，如果你对此有兴趣，应该仔细阅读 [ECMA262 文档](https://tc39.github.io/ecma262/#sec-assignment-operators \"ECMA262 文档\")，下面我会把我自己的分析和感悟贴出来。\n\n', '#t 从连等赋值看 AssignmentExpression\n\n## 闲言\n\n自从 Oracle 公司拥有 javascript 相关版权的行业文章出来后，我便开始有点担心我们要为所写的代码改名了。然而，我发现实际上根本没有任何浏览器厂商或其他 runtime 声明自己执行的脚本语言是 javascript，严谨的 Google 声明的是**ECMAScript**。OK，**ES**。\n\n## 问题\n\n我曾经看过，也写过**连等赋值**操作，形如：`let a = {b} = {b: 1}`。由于连等赋值出现频率低，带坑，我开始思考其存在的合理性，甚至怀疑**连等赋值**这玩意是不是开发者们利用赋值表达式返回值的特性而玩出来的一个小花样。对于赋值，简单情况下我们是习惯为单个变量单独声明初始化赋值或声明后二次赋值，语法形如：`declare name = value;`，复杂一点的有解构赋值：`declare {x, y}= {x: 1, y: 2};`，这两种赋值方式都是简单规范的，不会出任何问题。但连等赋值？呵呵。\n\n```javascript\nconst {x} = {y} = {x: 1, y: 2} // x = 1, y = 2\nx = 3 // 报错：Uncaught TypeError: Assignment to constant variable.\ny = 3 // ok\n```\n\n可以看到，`y`是对`declareType`是不感冒的。而且这种赋值方式下的新变量可能会有污染的危险：\n\n```javascript\n(() => {\n  let a = b = \'hello\' // a = \'hello\'，b = \'hello\'\n})()\nb // \'hello\'\na // 报错：Uncaught ReferenceError: a is not defined\n```\n\n写到这时，你应该能确定所谓连等赋值只是一个小手段罢了。但我们是否应该不要过于关注，只要以规范的方式写代码就行了？也许吧，我们应该先看看下面的这行代码：\n\n```javascript\nconst b = a.c = (() => a = {b: 1, c: 3})().b = 4\n```\n\n该代码能否运行？下面这个呢？\n\n```javascript\nconst b = (() => a = {b: 1, c: 3})().b = a.c = 4\n```\n\n事实上，赋值表达式 AssignmentExpression 有大量的知识点是在日常的代码工作中无法被触碰的，或是可避免的，但它们却默默地发挥了作用，如果你对此有兴趣，应该仔细阅读 [ECMA262 文档](https://tc39.github.io/ecma262/#sec-assignment-operators \"ECMA262 文档\")，下面我会把我自己的分析和感悟贴出来。\n\n<!-- more -->\n\n## 什么是赋值表达式\n\n赋值表达式，英文 AssignmentExpression，我缩写为 AsmE。我们平时赋值操作都是通过`name = value`这种方式来赋值，这种方式就是一种赋值表达式。除此之外，还有哪些方式呢？我罗列一下：\n\n* 条件表达式（? :）\n* yield 表达式\n* 箭头函数\n* 异步箭头函数\n* LeftHandSideExpression = AsmE\n* LeftHandSideExpression AssignmentOperator AsmE\n\n其中，`AssignmentOperator`是指赋值运算符，除了我们常用的`=`外，还有这些：\n`*=`，`/=`，`%=`，`+=`，`-=`，`<<=`，`>>=`，`>>>=`，`&=`，`|=`，`^=`，`**=`。下面我对罗列的几种表达式做个简单介绍：\n\n**条件表达式**：三元表达式，直接量（直接指向值和引用值的变量或属性，可以理解为无条件成立的表达式）；<br />\n**yield 表达式**：包括 `yield` 直接量和 `yield*`；<br />\n**箭头函数 / 异步箭头函数**：看似没问题，但为什么没有普通函数？我们知道`const foo = function () {}`是函数表达式，当我们把这种形式对比上面后会知道函数表达式可能会是`LeftHandSideExpression = AsmE`的一种表现，那么右侧的`function () {}`会是一个赋值表达式`AsmE`吗？**不是！！** 当你敲下`function () {}`时，尝试运行它会报错：`Uncaught SyntaxError: Unexpected token (`，这是因为`javascript`引擎会把它当成函数声明来解析，而`function`后必须要定义一个函数名称，而`(`括号是无法当成名称的，所以产生了这个错误。这就说明了，`function () {}`甚至还不是一个表达式，因为它无法单独运行，除非你用上**匿名函数声明**：`(function () {})`，但这不是表达式的范畴，我也不多说了。最后，你可以尝试运行一下`() => {}`。<br />\n**LeftHandSideExpression = AsmE**：我们常用的形式。`LeftHandSideExpression`简称`LHSE`，是一个有点儿复杂的概念，粗糙点来说就是赋值表达式的左手侧表达式，我们常用的有普通变量，对象属性，解构赋值等，具体概念下一节说。对于`LHSE = AsmE`，我们可以发现右侧`AsmE`也是个赋值表达式，那说明我们可以往`=`号右边继续塞赋值表达式，举例`LHSE = LHSE = AsmE`，这不就是我们开头说的连等赋值吗？所以你应该清楚**连等赋值**这个概念应该是咱们自己编出来的了。**注意！！注意！！注意！！** 我们虽然可以给右侧的`AsmE`无限嵌套各种类型的表达式，但实际上不应该如此，因为它会导致可怕的可读性和维护问题，还会对开发者有一定的要求。对于我们前面提出的一个表达式：`const b = (() => a = {b: 1, c: 3})().b = a.c = 4`，你敢说一般的开发者都清楚这些代码的执行流程和坑吗？在网上搜索的连等赋值教程中，有很多作者写出来的解析过程都是错误的，如：\"赋值表达式是从右侧开始执行的\"，实际上解析一个连等赋值表达式，应该从左边开始！<br />\n**LeftHandSideExpression AssignmentOperator AsmE**：基本等同上面的，后面会解释区别。\n\n`AsmE`就这么几种形式了，下面我们看看它对形式的要求，也就是报错。\n\n## 早期解析错误\n\n 1，对`LHSE = AsmE`的形式：\n\n* 如果 `LHSE` 是对象字面量或数组字面量，但不符合赋值模式的，则报 `Syntax Error`；\n* 如果 `LHSE` 不是对象字面量或数组字面量，且`IsValidSimpleAssignmentTarget(LHSE)`为`false`时，抛出`Reference Error`；\n\n第一点就是解构赋值的形式规范问题，第二点则判断`LHSE`能否被引用且赋值，那么`IsValidSimpleAssignmentTarget(LHSE)`什么时候才会为`false`呢？我罗列了一下：\n\n* yield 表达式\n* 箭头函数 / 异步箭头函数\n* LHSE = AsmE\n* LHSE AsmO AsmE\n\n以上这些情况都会为`false`，不过通常我们也不会这样写：`() => {} = 123`，`(a = 1) = 2`。而且，既然`LHSE`不可以为`AsmE`，那连等赋值操作`const {x} = {y} = {x: 1, y: 2}`的解析自然就不能从右边开始，只能从左边开始！这一点非常重要！！！如果不理解，请带着疑惑继续看到“执行过程”一节中的举例解析。\n\n2，对`LHSE AsmO AsmE`形式：\n\n* 如果`IsValidSimpleAssignmentTarget(LHSE)`为`false`时，抛出`Reference Error`；\n\n错误大家都懂，**那什么是早期错误**？比如，我弄个普通错误：\n\n```javascript\nconsole.log(\'我会先执行吗？\')\nconsole.log(i)\n\n// 我会先执行吗？\n// Uncaught ReferenceError: i is not defined\n```\n\n可以看到，前面的`log`先执行了，后面的`log`报错。那么，我试一下上面说的早期错误：\n\n```javascript\nconsole.log(\'我会先执行吗？\')\nconst {x, 3} = {x: 1}\n\n// Uncaught SyntaxError: Unexpected token }\n```\n\n可以看到，前面的`log`并没有先执行，错误直接阻挡了代码执行，所以**早期**的意思就在这，它是在代码执行前就要做的工作。如果你还有\"部分代码报错不影响功能\"的想法的话，请尽快丢掉。\n\nPS：ECMA 文档中定义此类错误的词语是`Early Errors`，直译过来是早期错误，但我个人认为既然此类代码错误是在运行前抛出的，那么其错误发现阶段应该是在编译解析阶段（把新语法和语法糖归并到旧实现方式中，是个过渡行为），翻译为“编译/解析 错误”可能更方便理解，我这里就称呼其为“早期解析错误”。\n\n## 执行过程\n\n`AsmE`的解析执行过程是有固定的流程的，只要理解了，再遇到`AsmE`应该就不会有什么疑惑了。\n\n先说说`LHSE = AsmE`的情况：\n\n```javascript\n1，如果 LHSE 既不是对象字面量也不是数组字面量，则\n  a，令 lref（left reference 左侧引用值） 为 LHSE 的执行结果\n  b，ReturnIfAbrupt(lref)\n  c，令 rref 为 AsmE\n  d，令 rval 为 GetValue(rref)\n  e，如果 IsAnonymousFunctionDefinition(AsmE) 且 IsIdentifierRef(LHSE) 都为 true，且如果 rval 没有 name 属性，则 setFunctionName(rval, GetReferenceedName(lref))\n  f，PutValue(lref, rval)\n  g，返回 rval\n2，采取 LHSE 定义的 AsmPattern\n3，令 rref 为 AsmE 的执行结果\n4，令 rval 为 GetValue(rref)\n5，根据 AsmPattern 和 rval 进行 DestructuringAssignmentEvaluation 解构赋值；\n6，返回 rval\n```\n\n对于`LHSE AsmO AsmE`：\n\n```javascript\n1，令 lref 为 LHSE 的执行结果\n2，令 lval 为 GetValue(lref)\n3，令 rref 为 AsmE 的执行结果\n4，令 rval 为 GetValue(rref)\n5，令 op 为 @= AsmO 中的 @\n6，令 r 为执行 lval op rval 的结果\n7，执行 PutValue(lref, r)\n8，return r\n```\n\n流程都很清晰，下面我们就举几个例子按照解析流程分析一下：\n\n``` javascript\n例子一：\nlet a = {x: 1}, b = a\na.x = a = {x: 2}\n\n分析：\nLHSE 为 a.x 也就是对象 {x: 1} 的属性 x，我们知道这里 lref（左侧引用）是指向对象 {x: 1} 的属性 x；\nAsmE 为 a = {x: 2}，则它也是一个 AsmE，执行结果是 a 指向了一个新的对象 {x: 2}，同时这个 AsmE 也返回这个对象；\n因此对象 {x: 1} 的属性 x 指向了返回的对象，也就是 a；\n所以有：\na = {x: 2}\nb.x = a\n```\n\n```javascript\n例子二：\nvar a, b\nMath.random() < 0.5 ? a : b += \'nb\'\na\nb\n\n分析：\nLHSE 是 Math.random() < 0.5 ? a : b，那么 lref 就是 Math.random() < 0.5 执行后对 a 或 b 的引用；\nlval 是 undefined；\nrval 是字符串 \'nb\'；\nop 是运算符加号，因此结果是 undefined + \'nb\' = \'undefinednb\'，a 和 b 有一个为 undefined；\n```\n\n经过这些例子，我们大概就能理解`AsmE`的解析执行流程了。\n\n## 总结\n\n当真是想不到一个简单的赋值表达式里面也会蕴藏着这么丰富细致的知识点。尽管我们很可能用不到这些知识，但理解其中的原理流程会有助于我们掌握 javascript 这门语言，尤其是其思想。');

-- ----------------------------
-- Table structure for `developer`
-- ----------------------------
DROP TABLE IF EXISTS `developer`;
CREATE TABLE `developer` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` text NOT NULL,
  `token` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of developer
-- ----------------------------
INSERT INTO `developer` VALUES ('1', '谭家威', 'wayne');

-- ----------------------------
-- Table structure for `tags`
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` text NOT NULL,
  `number` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES ('1', '闲聊', '1');
INSERT INTO `tags` VALUES ('2', 'java', '1');
INSERT INTO `tags` VALUES ('3', '泛型', '1');
INSERT INTO `tags` VALUES ('4', 'javascript', '1');
INSERT INTO `tags` VALUES ('5', '事件循环', '1');
INSERT INTO `tags` VALUES ('6', 'Android', '1');
INSERT INTO `tags` VALUES ('8', 'HTTP', '1');

-- ----------------------------
-- Table structure for `view_number`
-- ----------------------------
DROP TABLE IF EXISTS `view_number`;
CREATE TABLE `view_number` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `time` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of view_number
-- ----------------------------
INSERT INTO `view_number` VALUES ('1', '1');
INSERT INTO `view_number` VALUES ('2', '3');
INSERT INTO `view_number` VALUES ('3', '3');
INSERT INTO `view_number` VALUES ('4', '2');
INSERT INTO `view_number` VALUES ('5', '2');
INSERT INTO `view_number` VALUES ('7', '5');
INSERT INTO `view_number` VALUES ('8', '16');
